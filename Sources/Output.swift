import Foundation

/// Represents a report generated by this tool
struct Output: Codable {
    let xcSummary: XCResultSummary
    let failures: [OwnedFailure]
}

struct OutputError: Error {
    let message: String
}

// MARK: - Output Formats

extension Output {
    /// Returns the json representation of the report
    func jsonFormatted() throws -> String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .withoutEscapingSlashes, .sortedKeys]
        let data = try encoder.encode(self)
        return String(decoding: data, as: UTF8.self)
    }
}

extension Output {
    /// Returns markdown represention of the report
    func markdownFormatted() -> String {
        var markdown = """
        # Testing Completed
        
        | Summary               |    | 
        | --------------------- | -- |
        | **Result**            | \(xcSummary.result == "Failed" ? "‚ùå" : xcSummary.result) |
        | **Failed**            | \(xcSummary.failedTests) |
        | **Passed**            | \(xcSummary.passedTests) |
        | **Skipped**           | \(xcSummary.skippedTests) |
        | **Expected Failures** | \(xcSummary.expectedFailures) |
        | **Total Tests**       | \(xcSummary.totalTestCount) |
        
        
        """

        if failures.isEmpty == false {
            markdown += """
            ## Failures
            
            
            """

            for failure in failures {
                markdown += """
                1. `\(failure.xcFailure.testName)`
                
                    **Reason:** \(failure.xcFailure.failureText)
                    **Identifier:** `\(failure.xcFailure.testIdentifierString)`
                    **Module:** `\(failure.xcFailure.targetName)`
                    **Owner:** \(failure.owners.formatted(.list(type: .and)))
                
                
                """
            }
        }

        return markdown
    }
}
