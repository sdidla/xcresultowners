import Foundation
import ArgumentParser
import IndexStoreDB

@main struct xcresultowners: AsyncParsableCommand {
    enum OutputFormat: String, ExpressibleByArgument {
        case json
        case markdown
    }

    @Option(name: .shortAndLong, help: "Output format")
    var format: OutputFormat = .markdown

    @Option(name: .shortAndLong,help: "Path to libIndexStore.dylib. Use can pass in  $(xcrun xcodebuild -find-library libIndexStore.dylib) to auto-detect using xcrun")
    var libraryPath: String = "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libIndexStore.dylib"

    @Option(name: .shortAndLong, help: "Path to the index store. Usually at `/Index.noindex/DataStore` in the derived data folder of the project")
    var storePath: String

    @Option(name: .shortAndLong,help: "Path to the repository that contains github.com CODEOWNERS and source files")
    var repositoryPath: String

    @Argument(help: "Path to the xcresult summary obtained using `xcresulttool get test-results summary`")
    var xcResultJSONPath: String

    mutating func run() async throws {
        let repositoryURL = URL(fileURLWithPath: repositoryPath)
        let xcResultJSONURL = URL(fileURLWithPath: xcResultJSONPath)

        async let _ownedFilesList = resolveCodeOwners(repositoryURL: repositoryURL)
        async let _indexStoreDB = IndexStoreDB(storePath: storePath, libraryPath: libraryPath)

        let (ownedFilesList, indexStoreDB) = try await (_ownedFilesList, _indexStoreDB)

        log("Decoding XCResult... ")
        let data = try Data(contentsOf: xcResultJSONURL)
        let xcResultSummary = try JSONDecoder().decode(XCResultSummary.self, from: data)

        log("Generating Report...")
        let ownedFailures = xcResultSummary.testFailures.compactMap { failure in
            let location = indexStoreDB.locate(
                testCaseName: failure.testName,
                testIdentifier: failure.testIdentifierString,
                moduleName: failure.targetName
            )

            guard let location else {
                log("Unable to locate test: \(failure.testName)")
                return Report.OwnedFailure(xcFailure: failure, owners: [])
            }

            let fileURL = URL(fileURLWithPath: location.path)
            let ownedFile = ownedFilesList.first { $0.fileURL == fileURL }

            guard let owners = ownedFile?.owners else {
                log("Unable to locate owners: \(location.path)")
                return Report.OwnedFailure(xcFailure: failure, owners: [])
            }

            return Report.OwnedFailure(xcFailure: failure, owners: owners)
        }

        let report = Report(summary: xcResultSummary, failures: ownedFailures)

        if format == .json {
            try print(report.jsonFormatted())
        } else {
            print(report.markdownFormatted())
        }

        log("Done")
    }
}

// MARK: Report

/// Represents a report generated by this tool
struct Report: Codable {
    let summary: XCResultSummary
    let failures: [OwnedFailure]

    struct OwnedFailure: Codable {
        let xcFailure: XCResultSummary.TestFailure
        let owners: [String]
    }
}

extension Report {
    /// Returns the json representation of the report
    func jsonFormatted() throws -> String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted]
        let data = try encoder.encode(self)
        return String(decoding: data, as: UTF8.self)
    }
}

extension Report {
    /// Returns markdown represention of the report
    func markdownFormatted() -> String {
        var markdown = """
        # Testing Completed
        
        | Summary               |    | 
        | --------------------- | -- |
        | **Result**            | \(summary.result == "Failed" ? "‚ùå" : summary.result) |
        | **Failed**            | \(summary.failedTests) |
        | **Passed**            | \(summary.passedTests) |
        | **Skipped**           | \(summary.skippedTests) |
        | **Expected Failures** | \(summary.expectedFailures) |
        | **Total Tests**       | \(summary.totalTestCount) |
        
        
        """

        if failures.isEmpty == false {
            markdown += """
            ## Failures
            
            
            """

            for failure in failures {
                markdown += """
                1. `\(failure.xcFailure.testName)`
                
                    **Reason:** \(failure.xcFailure.failureText)
                    **Identifier:** `\(failure.xcFailure.testIdentifierString)`
                    **Module:** `\(failure.xcFailure.targetName)`
                    **Owner:** \(failure.owners.formatted(.list(type: .and)))
                
                
                """
            }
        }

        return markdown
    }
}

/// Log to standard error
private func log(_ message: String) {
    let datedMessage = Date().formatted(.iso8601) + " " + message + "\n"
    let datedMessageData = Data(datedMessage.utf8)
    try? FileHandle.standardError.write(contentsOf: datedMessageData)
}
